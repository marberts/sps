[{"path":"https://marberts/github.io/sps/LICENSE.html","id":"mit-license","dir":"","previous_headings":"","what":"MIT License","title":"NA","text":"Copyright (c) 2021 Steve Martin Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://marberts/github.io/sps/articles/sps.html","id":"drawing-a-sample-of-businesses","dir":"Articles","previous_headings":"","what":"Drawing a sample of businesses","title":"Drawing a Sequential Poisson Sample","text":"Consider problem drawing sample businesses order measure value sales current quarter. frame business register gives enumeration businesses operation, along revenue business previous year region headquartered. Associated business value sales current quarter, although values observable businesses. purpose drawing sample observe sales subset businesses, extrapolate value sales sample business entire population. Sales positively correlated last year’s revenue, basis sampling businesses proportional revenue. Budget constraints mean ’s feasible draw sample 100 businesses. Businesses operate different regions, sample stratified region. requires determining total sample size 100 allocated across regions. common approach allocation proportional total revenue region. sample size region hand, ’s now time draw sample observe value sales businesses. practice usually result survey ’s administered sampled units. important piece information sampling process design weights, enable estimating value sales population usual Horvitz-Thompson estimator. Horvitz-Thompson estimator (asymptotically) unbiased sequential Poisson sampling, surprise estimate fairly close true (unknown) value sales among businesses. practice ’s possible determine far estimate true value population. Instead, common measure quality estimate coefficient variation, requires estimating variance Horvitz-Thompson estimator. general approach estimating variance Horvitz-Thompson estimator construct bootstrap replicate weights design weights sample, compute collection estimates total based replicate weights, compute variance collection estimates. also analytic estimator variance Horvitz-Thompson estimator sequential Poisson sampling. ’s less flexible bootstrap estimator, precise.","code":"library(sps) set.seed(123654)  frame <- data.frame(   revenue = round(rlnorm(1e3) * 1000),    region = sample(1:3, 1e3, prob = c(0.2, 0.3, 0.5), replace = TRUE) )  head(frame) #>   revenue region #> 1    2676      1 #> 2    2158      1 #> 3    2046      3 #> 4     537      2 #> 5     266      3 #> 6    1991      1 sales <- round(frame$revenue * runif(1e3, 0.5, 2)) allocation <- with(frame, prop_allocation(revenue, 100, region)) allocation #>  1  2  3  #> 19 32 49 sample <- with(frame, sps(revenue, allocation, region))  survey <- cbind(frame[sample, ], sales = sales[sample])  head(survey) #>    revenue region sales #> 8     1422      3  1571 #> 25    2741      2  1843 #> 31     580      1   897 #> 37    4508      2  8659 #> 38    1007      3  1804 #> 42    2380      3  4740 survey$weight <- weights(sample)  head(survey) #>    revenue region sales    weight #> 8     1422      3  1571 11.254659 #> 25    2741      2  1843  6.070412 #> 31     580      1   897 27.752969 #> 37    4508      2  8659  3.690994 #> 38    1007      3  1804 15.892875 #> 42    2380      3  4740  6.724422 ht <- with(survey, sum(sales * weight)) ht #> [1] 2039582 ht / sum(sales) - 1 #> [1] 0.01325931 repweights <- sps_repweights(weights(sample), tau = 2)  var <- attr(repweights, \"tau\")^2 *    mean((colSums(survey$sales * repweights) - ht)^2)  sqrt(var) / ht #> [1] 0.09666341 sps_var <- function(y, w) {   y <- y[w > 1]   w <- w[w > 1]   n <- length(y)   Y <- sum(y * w)   n / (n - 1) * sum((1 - 1 / w) * (w * y - Y / n)^2) }  var <- with(   survey,    mapply(sps_var, split(sales, region), split(weight, region)) )               sqrt(sum(var)) / ht #> [1] 0.03067625"},{"path":"https://marberts/github.io/sps/articles/sps.html","id":"coordinating-samples","dir":"Articles","previous_headings":"","what":"Coordinating samples","title":"Drawing a Sequential Poisson Sample","text":"Suppose another sample businesses frame needed purpose measuring value sales. often desirable negatively coordinate samples businesses inundated responding surveys, without affecting statistical properties sample. sort coordination easily done associated business permanent random number, suitably “rotating” reduce overlap samples. Permanent random numbers can used methods sequential Poisson—procedure order sampling scheme (including simple random sampling). Although still meaningful overlap units samples, roughly half expected without using permanent random numbers.","code":"frame$prn <- runif(1000)  head(frame) #>   revenue region        prn #> 1    2676      1 0.72614569 #> 2    2158      1 0.30042829 #> 3    2046      3 0.09393538 #> 4     537      2 0.31786097 #> 5     266      3 0.23796557 #> 6    1991      1 0.80298366 pareto <- order_sampling(\\(x) x / (1 - x))  sample <- with(frame, sps(revenue, allocation, region, prn))  parsample <- with(frame, pareto(revenue, allocation, region, (prn - 0.5) %% 1))  length(intersect(sample, parsample)) / 100 #> [1] 0.09 replicate(1000, {   s <- with(frame, pareto(revenue, allocation, region))   length(intersect(sample, s)) / 100 }) |>    summary() #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>  0.1200  0.2000  0.2300  0.2275  0.2500  0.3500"},{"path":"https://marberts/github.io/sps/articles/sps.html","id":"topping-up","dir":"Articles","previous_headings":"","what":"Topping up","title":"Drawing a Sequential Poisson Sample","text":"sequential part sequential Poisson sampling means ’s easy grow sample. Suppose need sample 10 businesses region 1 sample drawn. Simply adding 10 units allocation region 1 results new sample includes previously sampled units, extra units can surveyed without discarding previously-collected data affecting statistical properties sample. proportional--size sampling scheme, critical sample size units become take-units. units already sample can “bump” previously sampled units, requiring larger sample size keep previously sampled units new sample. rare practice, usually requires smaller frame. solution simply increase sample previously sampled units included.","code":"sample <- with(frame, sps(revenue, allocation, region, prn))  sample_tu <- with(frame, sps(revenue, allocation + c(10, 0, 0), region, prn))  all(sample %in% sample_tu) #> [1] TRUE sapply(split(frame$revenue, frame$region), \\(x) ceiling(sum(x) / max(x))) #>  1  2  3  #> 17 32 32 set.seed(13026) x <- rlnorm(10) u <- runif(10)  ceiling(sum(x) / max(x)) #> [1] 4  sample <- sps(x, 4, prn = u)  sample %in% sps(x, 5, prn = u) #> [1]  TRUE  TRUE  TRUE FALSE sample %in% sps(x, 6, prn = u) #> [1] TRUE TRUE TRUE TRUE"},{"path":"https://marberts/github.io/sps/articles/sps.html","id":"bias-in-the-horvitz-thompson-estimator","dir":"Articles","previous_headings":"","what":"Bias in the Horvitz-Thompson estimator","title":"Drawing a Sequential Poisson Sample","text":"Despite ’s simplicity, sequential Poisson sampling asymptotically proportional size. means Horvitz-Thompson estimator can biased small samples, although bias usually negligible real-world sample sizes.","code":"sampling_distribution <- replicate(1000, {   sample <- with(frame, sps(revenue, allocation, region))   sum(sales[sample] * weights(sample)) })  summary(sampling_distribution / sum(sales) - 1) #>       Min.    1st Qu.     Median       Mean    3rd Qu.       Max.  #> -0.1043517 -0.0208040  0.0016497  0.0005927  0.0215847  0.1426320"},{"path":"https://marberts/github.io/sps/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Steve Martin. Author, maintainer, copyright holder. Justin Francis. Contributor.","code":""},{"path":"https://marberts/github.io/sps/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Martin S (2023). sps: Sequential Poisson Sampling. https://marberts.github.io/sps, https://github.com/marberts/sps.","code":"@Manual{,   title = {sps: Sequential Poisson Sampling},   author = {Steve Martin},   year = {2023},   note = {https://marberts.github.io/sps, https://github.com/marberts/sps}, }"},{"path":"https://marberts/github.io/sps/index.html","id":"sequential-poisson-sampling","dir":"","previous_headings":"","what":"Sequential Poisson Sampling","title":"Sequential Poisson Sampling","text":"Sequential Poisson sampling variation Poisson sampling drawing probability-proportional--size samples given number units, commonly used price-index surveys. package gives functions draw stratified sequential Poisson samples according method Ohlsson (1998), well order sample designs Rosén (1997), generate appropriate bootstrap replicate weights according generalized bootstrap method Beaumont Patak (2012).","code":""},{"path":"https://marberts/github.io/sps/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Sequential Poisson Sampling","text":"development version can found GitHub.","code":"install.packages(\"sps\") devtools::install_github(\"marberts/sps\")"},{"path":"https://marberts/github.io/sps/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Sequential Poisson Sampling","text":"Given vector sizes units population (e.g., revenue sampling businesses) desired sample size, stratified sequential Poisson sample can drawn sps() function. Allocations often proportional size drawing samples, prop_allocation() function provides variety methods generating proportional--size allocations. design weights sample can used generate bootstrap replicate weights sps_repwights() function.","code":"library(sps)  # Generate some data on sizes for 12 businesses in a single  # stratum as a simple example revenue <- c(1:10, 100, 150)  # Draw a sample of 6 businesses (samp <- sps(revenue, 6)) #> [1]  7  8  9 10 11 12  # Design weights and sampling strata are stored with the sample weights(samp) #> [1] 1.964286 1.718750 1.527778 1.375000 1.000000 1.000000 levels(samp) #> [1] \"TS\" \"TS\" \"TS\" \"TS\" \"TA\" \"TA\" # Add some strata stratum <- rep(c(\"a\", \"b\"), c(9, 3))  # Make an allocation (allocation <- prop_allocation(revenue, 6, stratum)) #> a b  #> 3 3  # Draw a stratified sample (samp <- sps(revenue, allocation, stratum)) #> [1]  4  6  7 10 11 12  weights(samp) #> [1] 3.750000 2.500000 2.142857 1.000000 1.000000 1.000000 levels(samp) #> [1] \"TS\" \"TS\" \"TS\" \"TA\" \"TA\" \"TA\" sps_repweights(weights(samp), 5, tau = 2) #>          [,1]     [,2]     [,3]     [,4]     [,5] #> [1,] 5.500000 1.750000 4.125000 3.625000 3.625000 #> [2,] 1.000000 2.750000 2.750000 1.000000 2.750000 #> [3,] 2.214286 1.714286 2.214286 3.285714 2.214286 #> [4,] 1.000000 1.000000 1.000000 1.000000 1.000000 #> [5,] 1.000000 1.000000 1.000000 1.000000 1.000000 #> [6,] 1.000000 1.000000 1.000000 1.000000 1.000000 #> attr(,\"tau\") #> [1] 2"},{"path":"https://marberts/github.io/sps/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Sequential Poisson Sampling","text":"Beaumont, J.-F. Patak, Z. (2012). Generalized Bootstrap Sample Surveys Special Attention Poisson Sampling. International Statistical Review, 80(1): 127-148. Ohlsson, E. (1998). Sequential Poisson Sampling. Journal Official Statistics, 14(2): 149-162. Rosén, B. (1997). sampling probability proportional size. Journal Statistical Planning Inference, 62(2): 159-191.","code":""},{"path":"https://marberts/github.io/sps/reference/prop_allocation.html","id":null,"dir":"Reference","previous_headings":"","what":"Proportional allocation — prop_allocation","title":"Proportional allocation — prop_allocation","text":"Generate proportional--size allocation stratified sampling.","code":""},{"path":"https://marberts/github.io/sps/reference/prop_allocation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Proportional allocation — prop_allocation","text":"","code":"prop_allocation(     x, n, strata, initial = 0,      divisor = function(a) a + 1,      ties = c(\"largest\", \"first\") )  expected_coverage(x, n, strata, alpha = 1e-3, cutoff = Inf)"},{"path":"https://marberts/github.io/sps/reference/prop_allocation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Proportional allocation — prop_allocation","text":"x positive finite numeric vector sizes units population (e.g., revenue drawing sample businesses). n positive integer giving total sample size across strata. Non-integers truncated towards 0. strata factor, something can coerced one, giving strata associated units population. initial positive integer vector giving initial (minimal) allocation stratum, ordered according levels strata. single integer recycled stratum using special algorithm ensure feasible allocation; see details. Non-integers truncated towards 0. default allows units allocated stratum. divisor divisor function divisor (highest-averages) apportionment method. default uses Jefferson (D'Hondt) method. See details possible functions. ties Either 'largest' break ties favor stratum largest size, 'first' break ties favor ordering strata. alpha number 0 1 units inclusion probabilities greater equal 1 - alpha set 1. default slightly larger 0. cutoff numeric vector cutoffs stratum, ordered according levels strata. Units x >= cutoff get inclusion probability 1. single value recycled strata. default apply cutoff.","code":""},{"path":"https://marberts/github.io/sps/reference/prop_allocation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Proportional allocation — prop_allocation","text":"prop_allocation() function gives sample size level strata proportional sum x across strata adds n. done using divisor (highest-averages) apportionment method (Balinksi Young, 1982, Appendix ), number different divisor functions: Jefferson/D'Hondt \\() + 1 Webster/Sainte-Laguë \\() + 0.5 Imperiali \\() + 2 Huntington-Hill \\() sqrt(* (+ 1)) Danish \\() + 1 / 3 Adams \\() Dean \\() * (+ 1) / (+ 0.5) Note divisor function \\(d(0) = 0\\) (.e., Huntington-Hill, Adams, Dean) initial allocation least 1 strata. cases, ties broken according sum x ties = 'largest'; otherwise, ties = 'first', ties broken according levels strata. cases number units non-zero size stratum smaller allocation, allocation stratum set number available units, remaining sample size reallocated strata proportional x. similar PROC SURVEYSELECT SAS ALLOC = PROPORTIONAL. Passing single integer initial allocation first checks recycling value stratum result allocation larger sample size. , value reduced recycling exceed sample size. recycled vector can reduced cases exceeds number units stratum, result initial allocation. special recycling ensures initial allocation feasible. expected_coverage() function gives average number strata covered ordinary Poisson sampling without stratification. sequential ordinary Poisson sampling sample size average, gives approximation coverage sequential Poisson sampling. function can also used calculate, e.g., expected number enterprises covered within stratum sampling business establishments.","code":""},{"path":"https://marberts/github.io/sps/reference/prop_allocation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Proportional allocation — prop_allocation","text":"prop_allocation() returns named integer vector sample sizes stratum strata. expected_coverage() returns expected number strata covered sample design.","code":""},{"path":"https://marberts/github.io/sps/reference/prop_allocation.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Proportional allocation — prop_allocation","text":"Balinksi, M. L. Young, H. P. (1982). Fair Representation: Meeting Ideal One Man, One Vote. Yale University Press.","code":""},{"path":[]},{"path":"https://marberts/github.io/sps/reference/prop_allocation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Proportional allocation — prop_allocation","text":"","code":"# Make a population with units of different size x <- c(rep(1:9, each = 3), 100, 100, 100)  # ... and 10 strata s <- rep(letters[1:10], each = 3)  # Should get about 7 to 8 strata in a sample on average expected_coverage(x, 15, s) #> [1] 7.666667  # Generate an allocation with all 10 prop_allocation(x, 15, s, initial = 1) #> a b c d e f g h i j  #> 1 1 1 1 1 1 2 2 2 3"},{"path":"https://marberts/github.io/sps/reference/sps-package.html","id":null,"dir":"Reference","previous_headings":"","what":"Sequential Poisson Sampling — sps-package","title":"Sequential Poisson Sampling — sps-package","text":"Sequential Poisson sampling variation Poisson sampling drawing probability-proportional--size samples given number units, commonly used price-index surveys. package gives functions draw stratified sequential Poisson samples according method Ohlsson (1998), well order sample designs Rosén (1997), generate appropriate bootstrap replicate weights according generalized bootstrap method Beaumont Patak (2012).","code":""},{"path":"https://marberts/github.io/sps/reference/sps-package.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sequential Poisson Sampling — sps-package","text":"Given vector sizes units population (e.g., revenue sampling businesses) desired sample size, stratified sequential Poisson sample can drawn sps() function. Allocations often proportional size drawing samples, prop_allocation() function provides variety methods generating proportional--size allocations. sample drawn, design weights sample can used generate bootstrap replicate weights sps_repweights() function. vignette gives extended example workflow: vignette(\"sps\"). Sequential Poisson sampling often used sample data price indexes. Balk (2008, chapter 5) discusses construction price indexes data sampled using probability-proportional--size methods, resulting statistical properties. CPI manual (2020, chapter 4) describes methods sampling price data. Tillé (2020, chapter 5) gives practical overview different probability-proportional--size sampling methods; compared existing implementations several methods (e.g., Brewer, Sampford, maximum entropy), however, sequential Poisson sampling relatively fast larger frames.","code":""},{"path":"https://marberts/github.io/sps/reference/sps-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Sequential Poisson Sampling — sps-package","text":"Balk, B. M. (2008). Price Quantity Index Numbers. Cambridge University Press. Beaumont, J.-F. Patak, Z. (2012). Generalized Bootstrap Sample Surveys Special Attention Poisson Sampling. International Statistical Review, 80(1): 127-148. ILO, IMF, OECD, Eurostat, UN, World Bank. (2020). Consumer Price Index Manual: Theory Practice. International Monetary Fund. Ohlsson, E. (1998). Sequential Poisson Sampling. Journal Official Statistics, 14(2): 149-162. Rosén, B. (1997). sampling probability proportional size. Journal Statistical Planning Inference, 62(2): 159-191. Tillé, Y. (2020). Sampling estimation finite populations. Wiley.","code":""},{"path":[]},{"path":"https://marberts/github.io/sps/reference/sps-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Sequential Poisson Sampling — sps-package","text":"Maintainer: Steve Martin stevemartin041@gmail.com contributors: Justin Francis","code":""},{"path":"https://marberts/github.io/sps/reference/sps.html","id":null,"dir":"Reference","previous_headings":"","what":"Stratified sequential Poisson sampling — sps","title":"Stratified sequential Poisson sampling — sps","text":"Draw stratified probability-proportional--size sample using sequential ordinary Poisson methods. Includes functions calculate first-order inclusion probabilities generate order sampling schemes.","code":""},{"path":"https://marberts/github.io/sps/reference/sps.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Stratified sequential Poisson sampling — sps","text":"","code":"## Sequential Poisson sampling sps(x, n, strata = gl(1, length(x)), prn = NULL, alpha = 1e-3, cutoff = Inf)  ## Ordinary Poisson sampling ps(x, n, strata = gl(1, length(x)), prn = NULL, alpha = 1e-3, cutoff = Inf)  inclusion_prob(x, n, strata = gl(1, length(x)), alpha = 1e-3, cutoff = Inf)  ## Function factory order_sampling(dist)"},{"path":"https://marberts/github.io/sps/reference/sps.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Stratified sequential Poisson sampling — sps","text":"x positive finite numeric vector sizes units population (e.g., revenue drawing sample businesses). n positive integer vector giving sample size stratum, ordered according levels strata. single value recycled strata. Non-integers truncated towards 0. strata factor, something can coerced one, giving strata associated units population. default place units single stratum. prn numeric vector permanent random numbers units population, distributed uniform 0 1. default use permanent random numbers, instead generating random vector function called. alpha numeric vector values 0 1 stratum, ordered according levels strata. Units inclusion probabilities greater equal 1 - alpha set 1 stratum. single value recycled strata. default slightly larger 0. cutoff positive numeric vector cutoffs stratum, ordered according levels strata. Units x >= cutoff get inclusion probability 1 fo stratum. single value recycled strata. default apply cutoff. dist function gives inverse fixed distribution shape order sampling scheme. See details.","code":""},{"path":"https://marberts/github.io/sps/reference/sps.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Stratified sequential Poisson sampling — sps","text":"sps() function draws sample according sequential Poisson procedure, details given Ohlsson (1998). also called uniform order sampling, type order sampling; see Rosén (1997, 2000) general presentation method. method used PROC SURVEYSELECT SAS METHOD = SEQ_POISSON. stratum, sequential Poisson procedure starts stratifying units population based (target) inclusion probabilities, \\(\\pi = nx / \\sum x\\). Units \\(\\pi = 0\\) placed take-none stratum, units \\(0 < \\pi < 1\\) placed take-stratum, units \\(\\pi = 1\\) placed take-stratum. units appropriately stratified, sample take-units drawn assigning unit value \\(\\xi = u / \\pi\\), \\(u\\) random deviate uniform distribution 0 1. units smallest values \\(\\xi\\) included sample, along take-units. (Ties \\(\\xi\\) technically measure-zero event---practice broken position.) results fixed sample size expense sampling procedure approximately probability-proportional--size (.e., inclusion probabilities sample design close exactly equal \\(\\pi\\); see Matei Tillé, 2007, details exact computation). Ordinary Poisson sampling follows procedure , except units \\(\\xi < 1\\) included sample; consequently, contain fixed number units, procedure strictly probability-proportional--size. Despite difference, standard Horvitz-Thompson estimator total (take-stratum) asymptotically unbiased, normally distributed, equally efficient procedures. ps() function draws sample using ordinary Poisson method. useful feature sequential ordinary Poisson sampling ability coordinate samples using permanent random numbers \\(u\\). Keeping \\(u\\) fixed updating sample retains larger number overlapping units, whereas switching \\(u\\) \\(u - z \\bmod 1\\) \\(1 - (u - z \\bmod 1)\\), \\(z\\) 0 1, drawing different samples frame reduces number overlapping units. Inclusion probabilities can greater 1 practice, constructed iteratively taking units \\(\\pi \\geq 1 - \\alpha\\) (largest smallest) assigning units inclusion probability 1, remaining inclusion probabilities recalculated step. \\(\\alpha > 0\\), ties among units size broken position. noted Ohlsson, can useful set \\(\\alpha\\) small positive value, default behavior. inclusion_prob() function computes stratum-wise inclusion probabilities. Despite focus sequential Poisson sampling, order sampling procedures follow approach sequential Poisson sampling. order_sampling() function can used generate order sampling functions passing appropriate function make ranking variable \\(\\xi\\): Sequential Poisson sampling \\(x) x Successive sampling \\(x) log(1 - x) Pareto sampling \\(x) x / (1 - x)","code":""},{"path":"https://marberts/github.io/sps/reference/sps.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Stratified sequential Poisson sampling — sps","text":"sps() ps() return object class sps. integer vector indices units population form sample, along weights attribute gives design (inverse probability) weights unit sample (keeping mind sequential Poisson sampling approximately probability-proportional--size). weights() can used access design weights attribute sps object, levels() can used determine units take-take-strata. Mathematical binary/unary operators strip attributes, replacement. inclusion_prob() returns numeric vector inclusion probabilities unit population. order_sampling returns function interface sps() ps().","code":""},{"path":"https://marberts/github.io/sps/reference/sps.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Stratified sequential Poisson sampling — sps","text":"Matei, ., Tillé, Y. (2007). Computational aspects order \\(\\pi\\)ps sampling schemes. Computational Statistics & Data Analysis, 51: 3703-3717. Ohlsson, E. (1998). Sequential Poisson Sampling. Journal Official Statistics, 14(2): 149-162. Rosén, B. (1997). sampling probability proportional size. Journal Statistical Planning Inference, 62(2): 159-191. Rosén, B. (2000). inclusion probabilities order \\(\\pi\\)ps sampling. Journal Statistical Planning Inference, 90(1): 117-143.","code":""},{"path":[]},{"path":"https://marberts/github.io/sps/reference/sps.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Stratified sequential Poisson sampling — sps","text":"","code":"# Make a population with units of different size x <- c(1:10, 100)  #---- Sequential Poisson sampling ---- # Draw a sequential Poisson sample (samp <- sps(x, 5)) #> [1]  4  7  9 10 11  # Get the design (inverse probability) weights weights(samp) #> [1] 3.437500 1.964286 1.527778 1.375000 1.000000  # All units except 11 are in the take-some (TS) stratum levels(samp) #> [1] \"TS\" \"TS\" \"TS\" \"TS\" \"TA\"  # Ensure that the top 10% of units are in the sample sps(x, 5, cutoff = quantile(x, 0.9)) #> [1]  7  8  9 10 11  #---- Ordinary Poisson sampling ---- # Ordinary Poisson sampling gives a random sample size for the  # take-some stratum ps(x, 5) #> [1]  2  7  8  9 10 11  # Use the inclusion probabilities to calculate the variance of the # sample size with(   list(pi = inclusion_prob(x, 5)),    sum(pi * (1 - pi)) ) #> [1] 1.963636  #---- Stratified Sequential Poisson sampling ---- # Draw a stratified sample with a proportional allocation strata <- rep(letters[1:4], each = 5) (allocation <- prop_allocation(1:20, 12, strata)) #> a b c d  #> 1 2 4 5  (samp <- sps(1:20, allocation, strata)) #>  [1]  5  6 10 11 12 13 15 16 17 18 19 20  # Use the Horvitz-Thompson estimator to estimate the total y <- runif(20) * 1:20 sum(weights(samp) * y[samp]) #> [1] 85.98722  #---- Useful properties of Sequential Poisson sampling ---- # It can be useful to set 'prn' in order to extend the sample # to get a fixed net sample u <- runif(11) (samp <- sps(x, 6, prn = u)) #> [1]  5  6  8  9 10 11  # Removing unit 5 gives the same net sample sps(x[-samp[5]], 6, prn = u[-samp[5]]) #> [1]  5  6  7  8  9 10  # Also useful for topping up a sample all(samp %in% sps(x, 7, prn = u)) #> [1] TRUE  #---- Other order-sampling methods ---- # Generate new order-sampling functions from the parameters of # the inverse generalized Pareto distribution igpd <- function(shape, scale = 1, location = 0) {   if (shape == 0) {     function(x) -scale * log(1 - x) + location   } else {     function(x) scale * (1 - (1 - x)^shape) / shape + location   } }  order_sampling2 <- function(x) order_sampling(igpd(x))  order_sampling2(1)(x, 6, prn = u) # sequential Poisson #> [1]  5  6  8  9 10 11 order_sampling2(0)(x, 6, prn = u) # successive #> [1]  5  6  7  9 10 11 order_sampling2(-1)(x, 6, prn = u) # Pareto #> [1]  2  5  6  9 10 11"},{"path":"https://marberts/github.io/sps/reference/sps_repweights.html","id":null,"dir":"Reference","previous_headings":"","what":"Bootstrap replicate weights for sequential Poisson sampling — sps_repweights","title":"Bootstrap replicate weights for sequential Poisson sampling — sps_repweights","text":"Produce bootstrap replicate weights appropriate Poisson sampling, therefore approximately correct sequential Poisson sampling.","code":""},{"path":"https://marberts/github.io/sps/reference/sps_repweights.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bootstrap replicate weights for sequential Poisson sampling — sps_repweights","text":"","code":"sps_repweights(w, replicates = 1000, tau = 1, dist = NULL)"},{"path":"https://marberts/github.io/sps/reference/sps_repweights.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bootstrap replicate weights for sequential Poisson sampling — sps_repweights","text":"w numeric vector design (inverse probability) weights (sequential) Poisson sample. replicates positive integer gives number bootstrap replicates (1,000 default). Non-integers truncated towards 0. tau number greater equal 1 gives rescale factor bootstrap weights. Setting 1 (default) rescale weights. dist function produces random deviates mean 0 standard deviation 1, rnorm. default uses pseudo-population method section 4.1 Beaumont Patak (2012); see details.","code":""},{"path":"https://marberts/github.io/sps/reference/sps_repweights.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Bootstrap replicate weights for sequential Poisson sampling — sps_repweights","text":"Replicate weights constructed using generalized bootstrap method Beaumont Patak (2012). method takes vector design weights \\(w\\), finds vector adjustments \\(\\) bootstrap replicate, calculates replicate weights \\(w\\). two ways calculate adjustments \\(\\). default pseudo-population method randomly rounds \\(w\\) replicate produce collection integer weights \\(w'\\) used generate random vector \\(b\\) binomial distribution. vector adjustments \\(= 1 + b - w' / w\\). Specifying deviates-generating function dist uses function produce random vector \\(d\\) used make adjustment \\(= 1 + d \\sqrt{1 - 1 / w}\\). adjustments can rescaled value \\(\\tau \\geq 1\\) prevent negative replicate weights. rescaling, adjustment becomes \\((+ \\tau - 1) / \\tau\\). \\(\\tau > 1\\) resulting bootstrap variance estimator multiplied \\(\\tau^2\\).","code":""},{"path":"https://marberts/github.io/sps/reference/sps_repweights.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bootstrap replicate weights for sequential Poisson sampling — sps_repweights","text":"matrix bootstrap replicate weights replicates columns (one replicate) length(w) rows (one unit sample), value tau attribute.","code":""},{"path":"https://marberts/github.io/sps/reference/sps_repweights.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Bootstrap replicate weights for sequential Poisson sampling — sps_repweights","text":"alternative bootstrap, Ohlsson (1998, equations 2.13) proposes analytic estimator variance total \\(\\hat Y = \\sum wy\\) (take-units) sequential Poisson sampling: $$V(\\hat Y) = \\frac{n}{n - 1} \\sum \\left(1 - \\frac{1}{w}\\right) \\left(wy - \\frac{\\hat Y}{n}\\right)^2.$$ See Rosén (1997, equation 3.11) general version estimator can applied order sampling schemes. Replacing left-correction \\(n / (m - 1)\\), \\(m\\) number units sample, gives similar estimator total ordinary Poisson sampling, \\(\\hat Y = n / m \\sum wy\\).","code":""},{"path":"https://marberts/github.io/sps/reference/sps_repweights.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Bootstrap replicate weights for sequential Poisson sampling — sps_repweights","text":"Beaumont, J.-F. Patak, Z. (2012). Generalized Bootstrap Sample Surveys Special Attention Poisson Sampling. International Statistical Review, 80(1): 127-148. Ohlsson, E. (1998). Sequential Poisson Sampling. Journal Official Statistics, 14(2): 149-162. Rosén, B. (1997). sampling probability proportional size. Journal Statistical Planning Inference, 62(2): 159-191.","code":""},{"path":[]},{"path":"https://marberts/github.io/sps/reference/sps_repweights.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Bootstrap replicate weights for sequential Poisson sampling — sps_repweights","text":"","code":"# Make a population with units of different size x <- c(1:10, 100)  # Draw a sequential Poisson sample (samp <- sps(x, 5)) #> [1]  5  8  9 10 11  # Make some bootstrap replicates dist <- list(   pseudo_population = NULL,   standard_normal = rnorm,   exponential = \\(x) rexp(x) - 1,   uniform = \\(x) runif(x, -sqrt(3), sqrt(3)) )  lapply(dist, sps_repweights, w = weights(samp), replicates = 5, tau = 2) #> $pseudo_population #>          [,1]     [,2]     [,3]     [,4]     [,5] #> [1,] 4.000000 2.625000 1.750000 4.000000 3.125000 #> [2,] 2.437500 2.437500 1.578125 2.437500 0.718750 #> [3,] 1.291667 1.791667 2.055556 1.291667 2.055556 #> [4,] 0.875000 1.562500 1.562500 1.062500 0.375000 #> [5,] 1.000000 1.000000 1.000000 1.000000 1.000000 #> attr(,\"tau\") #> [1] 2 #>  #> $standard_normal #>          [,1]     [,2]      [,3]      [,4]     [,5] #> [1,] 3.605473 4.101598 1.9250720 0.4323578 1.962528 #> [2,] 1.515005 1.443399 2.5765732 1.7029468 2.053811 #> [3,] 1.906385 0.809544 1.3524266 1.4480253 2.571348 #> [4,] 1.496202 1.668285 0.9475164 1.1868081 1.527011 #> [5,] 1.000000 1.000000 1.0000000 1.0000000 1.000000 #> attr(,\"tau\") #> [1] 2 #>  #> $exponential #>          [,1]     [,2]     [,3]     [,4]     [,5] #> [1,] 2.130484 4.871911 1.736190 2.482225 2.143744 #> [2,] 1.944213 2.071920 1.315455 1.206224 1.175053 #> [3,] 1.248890 1.842357 2.590555 1.410254 1.116373 #> [4,] 1.173416 1.178504 1.021583 1.944175 1.874720 #> [5,] 1.000000 1.000000 1.000000 1.000000 1.000000 #> attr(,\"tau\") #> [1] 2 #>  #> $uniform #>          [,1]     [,2]      [,3]      [,4]      [,5] #> [1,] 4.389582 3.183583 4.0657842 2.4758416 3.4188592 #> [2,] 2.096831 1.083762 0.9429729 1.5022560 0.9228596 #> [3,] 1.138733 1.016631 1.5523543 2.3017025 1.6607802 #> [4,] 1.415506 1.882710 1.7324815 0.8453495 1.0210732 #> [5,] 1.000000 1.000000 1.0000000 1.0000000 1.0000000 #> attr(,\"tau\") #> [1] 2 #>"},{"path":"https://marberts/github.io/sps/news/index.html","id":"changes-in-version-052","dir":"Changelog","previous_headings":"","what":"Changes in version 0.5.2","title":"Changes in version 0.5.2","text":"Added vignette. sps objects now inherit numeric instead integer. Replacement methods length levels longer mangle sps objects. single sample size now recycled stratum drawing samples calculating inclusion probabilities. Added cutoff argument puts units sizes cutoff take-stratum.","code":""},{"path":"https://marberts/github.io/sps/news/index.html","id":"changes-in-version-050","dir":"Changelog","previous_headings":"","what":"Changes in version 0.5.0","title":"Changes in version 0.5.0","text":"CRAN release: 2023-04-10 prop_allocation() gets new argument breaking ties. default now breaks ties according references; old behavior can setting ties = \"first\". Argument names prop_allocation(), expected_coverage(), sps_repweights() changed either descriptive, consistent names functions. Fixed bug calculating inclusion probabilities result ties breaking according position (documented) alpha > 0. Simplified codebase.","code":""},{"path":"https://marberts/github.io/sps/news/index.html","id":"changes-in-version-041","dir":"Changelog","previous_headings":"","what":"Changes in version 0.4.1","title":"Changes in version 0.4.1","text":"CRAN release: 2023-02-12 Added new argument alpha calculating inclusion probabilities. can used place units inclusion probabilities close 1 take-stratum. implicitly 0 previous versions, current default 1e-4. functions can now accept size vectors zeros. sps() now faster, especially large populations. Added function factory generate order sampling methods.","code":""},{"path":"https://marberts/github.io/sps/news/index.html","id":"changes-in-version-030","dir":"Changelog","previous_headings":"","what":"Changes in version 0.3.0","title":"Changes in version 0.3.0","text":"CRAN release: 2022-11-23 version number non-backwards compatible changes address undesirable behavior functions. Largest-remainder rounding result prop_allocation() giving visibly non-proportional allocations, removed. default now Jefferson/D’Hondt method. method argument prop_allocation() replaced divisor argument supply divisor function rounding. initial argument prop_allocation() recycled ensure initial allocation feasible supplying single value. change strictly backwards compatible values ordinarily recycled longer give error. Supplying vector permanent random numbers sps() ps() generated given seed now gives result setting seed prior calling sps() ps(). means setting seed given value can give different sample compared older versions, although permanent random numbers used reproducible samples. argument name specifying strata now strata instead s functions. Partial matching means change won’t break existing code.","code":""},{"path":"https://marberts/github.io/sps/news/index.html","id":"changes-in-version-020","dir":"Changelog","previous_headings":"","what":"Changes in version 0.2.0","title":"Changes in version 0.2.0","text":"CRAN release: 2022-10-28 prop_allocation() gains two new arguments: initial sets initial allocation stratum. saves manually keep track initial allocation adjust sample size passed prop_allocation(). method selects apportionment method used round proportional allocation integer values. particular, highest-averages methods can used place largest-remainder method. defaults arguments change behavior function previous versions. convenience functions added: ps() drawing ordinary Poisson samples interface sps(). inclusion_prob() generating inclusion probabilities frame. expected_coverage() calculating expected number strata sampling frame. internals updated improve performance large frames. functions little argument checking. particular, longer possible pass length 0 arguments sps(), prop_allocation(), sps_repweights().","code":""},{"path":"https://marberts/github.io/sps/news/index.html","id":"changes-in-version-013","dir":"Changelog","previous_headings":"","what":"Changes in version 0.1.3","title":"Changes in version 0.1.3","text":"CRAN release: 2022-02-09 Added option draw samples permanent random numbers. Added methods Math, Ops, [<-, [[<- strip attributes sps objects treat result sample.","code":""},{"path":"https://marberts/github.io/sps/news/index.html","id":"changes-in-version-012","dir":"Changelog","previous_headings":"","what":"Changes in version 0.1.2","title":"Changes in version 0.1.2","text":"CRAN release: 2021-12-11 sps() now returns integer vector (possible), rather double. printing matrix replicate weights now shows row names ().","code":""}]
