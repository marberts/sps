[{"path":"https://marberts.github.io/sps/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2021 Steve Martin Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://marberts.github.io/sps/articles/sps.html","id":"drawing-a-sample-of-businesses","dir":"Articles","previous_headings":"","what":"Drawing a sample of businesses","title":"Drawing a Sequential Poisson Sample","text":"Consider problem drawing sample businesses order measure value sales current quarter. frame business register gives enumeration businesses operation, along revenue business previous year region headquartered. Associated business value sales current quarter, although values observable businesses. purpose drawing sample observe sales subset businesses, extrapolate value sales sample business entire population. Sales positively correlated last year’s revenue, basis sampling businesses proportional revenue. Budget constraints mean ’s feasible draw sample 100 businesses. Businesses operate different regions, sample stratified region. requires determining total sample size 100 allocated across regions. common approach allocation proportional total revenue region. sample size region hand, ’s now time draw sample observe value sales businesses. practice usually result survey ’s administered sampled units. important piece information sampling process design weights, enable estimating value sales population usual Horvitz-Thompson estimator. Horvitz-Thompson estimator (asymptotically) unbiased sequential Poisson sampling, surprise estimate fairly close true (unknown) value sales among businesses. practice ’s possible determine far estimate true value population. Instead, common measure quality estimate coefficient variation, requires estimating variance Horvitz-Thompson estimator. general approach estimating variance Horvitz-Thompson estimator construct bootstrap replicate weights design weights sample, compute collection estimates total based replicate weights, compute variance collection estimates. also analytic estimator variance Horvitz-Thompson estimator sequential Poisson sampling. ’s less flexible bootstrap estimator, precise.","code":"library(sps) set.seed(123654)  frame <- data.frame(   revenue = round(rlnorm(1e3) * 1000),   region = sample(1:3, 1e3, prob = c(0.2, 0.3, 0.5), replace = TRUE) )  head(frame) #>   revenue region #> 1    2676      1 #> 2    2158      1 #> 3    2046      3 #> 4     537      2 #> 5     266      3 #> 6    1991      1 sales <- round(frame$revenue * runif(1e3, 0.5, 2)) allocation <- with(frame, prop_allocation(revenue, 100, region)) allocation #>  1  2  3  #> 19 32 49 sample <- with(frame, sps(revenue, allocation, region))  survey <- cbind(frame[sample, ], sales = sales[sample])  head(survey) #>    revenue region sales #> 8     1422      3  1571 #> 25    2741      2  1843 #> 31     580      1   897 #> 37    4508      2  8659 #> 38    1007      3  1804 #> 42    2380      3  4740 survey$weight <- weights(sample)  head(survey) #>    revenue region sales    weight #> 8     1422      3  1571 11.254659 #> 25    2741      2  1843  6.070412 #> 31     580      1   897 27.752969 #> 37    4508      2  8659  3.690994 #> 38    1007      3  1804 15.892875 #> 42    2380      3  4740  6.724422 ht <- with(survey, sum(sales * weight)) ht #> [1] 2039582 ht / sum(sales) - 1 #> [1] 0.01325931 repweights <- sps_repweights(weights(sample))  var <- attr(repweights, \"tau\")^2 *   mean((colSums(survey$sales * repweights) - ht)^2)  sqrt(var) / ht #> [1] 0.09666341 sps_var <- function(y, w) {   y <- y[w > 1]   w <- w[w > 1]   n <- length(y)   total <- sum(y * w)   n / (n - 1) * sum((1 - 1 / w) * (w * y - total / n)^2) }  var <- with(   survey,   mapply(sps_var, split(sales, region), split(weight, region)) )  sqrt(sum(var)) / ht #> [1] 0.03067625"},{"path":"https://marberts.github.io/sps/articles/sps.html","id":"coordinating-samples","dir":"Articles","previous_headings":"","what":"Coordinating samples","title":"Drawing a Sequential Poisson Sample","text":"Suppose another sample businesses frame needed purpose measuring value sales. often desirable negatively coordinate samples businesses inundated responding surveys, without affecting statistical properties sample. sort coordination easily done associating business permanent random number, suitably “rotating” reduce overlap samples. Permanent random numbers can used methods sequential Poisson—procedure order sampling scheme (including simple random sampling). Although still meaningful overlap units samples, roughly half expected without using permanent random numbers.","code":"frame$prn <- runif(1000)  head(frame) #>   revenue region        prn #> 1    2676      1 0.72614569 #> 2    2158      1 0.30042829 #> 3    2046      3 0.09393538 #> 4     537      2 0.31786097 #> 5     266      3 0.23796557 #> 6    1991      1 0.80298366 pareto <- order_sampling(\\(x) x / (1 - x))  sample <- with(frame, sps(revenue, allocation, region, prn))  parsample <- with(frame, pareto(revenue, allocation, region, (prn - 0.5) %% 1))  length(intersect(sample, parsample)) / 100 #> [1] 0.09 replicate(1000, {   s <- with(frame, pareto(revenue, allocation, region))   length(intersect(sample, s)) / 100 }) |>   summary() #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>  0.1200  0.2000  0.2300  0.2275  0.2500  0.3500"},{"path":"https://marberts.github.io/sps/articles/sps.html","id":"topping-up","dir":"Articles","previous_headings":"","what":"Topping up","title":"Drawing a Sequential Poisson Sample","text":"sequential part sequential Poisson sampling means ’s easy grow sample. Suppose need sample 10 businesses region 1 sample drawn. Simply adding 10 units allocation region 1 results new sample includes previously sampled units, extra units can surveyed without discarding previously-collected data affecting statistical properties sample. proportional--size sampling scheme, critical sample size units become take-units. units already sample can “bump” previously sampled units, requiring larger sample size keep previously sampled units new sample. can seen finding sample size unit enters take-stratum. rare practice. example point increasing sample size drops unit previously included sample. Seeing action requires different data. solution problem simply increase size sample previously sampled units included.","code":"sample <- with(frame, sps(revenue, allocation, region, prn))  sample_tu <- with(frame, sps(revenue, allocation + c(10, 0, 0), region, prn))  all(sample %in% sample_tu) #> [1] TRUE Map(\\(x) head(becomes_ta(x)), split(frame$revenue, frame$region)) #> $`1` #> [1]  86  98 102 174 161 160 #>  #> $`2` #> [1] 278 157 261 254 110 284 #>  #> $`3` #> [1] 283 500 500 344 449 482 set.seed(13026) x <- rlnorm(10) u <- runif(10)  becomes_ta(x) #>  [1] 10  4  5  5  5  9  8 10  9  9  sample <- sps(x, 4, prn = u)  sample %in% sps(x, 5, prn = u) #> [1]  TRUE  TRUE  TRUE FALSE sample %in% sps(x, 6, prn = u) #> [1] TRUE TRUE TRUE TRUE"},{"path":"https://marberts.github.io/sps/articles/sps.html","id":"bias-in-the-horvitz-thompson-estimator","dir":"Articles","previous_headings":"","what":"Bias in the Horvitz-Thompson estimator","title":"Drawing a Sequential Poisson Sample","text":"Despite ’s simplicity, sequential Poisson sampling asymptotically proportional size. means Horvitz-Thompson estimator can biased small samples, although bias usually negligible real-world sample sizes. generally, distribution inclusion probabilities usually close expected sequential Poisson sampling exactly proportional size.1","code":"sampling_distribution <- replicate(1000, {   sample <- with(frame, sps(revenue, allocation, region))   sum(sales[sample] * weights(sample)) })  summary(sampling_distribution / sum(sales) - 1) #>       Min.    1st Qu.     Median       Mean    3rd Qu.       Max.  #> -0.1043517 -0.0208040  0.0016497  0.0005927  0.0215847  0.1426320 set.seed(123456) n <- 5e3 frame1 <- subset(frame, region == 1)  pi_est <- tabulate(   replicate(n, sps(frame1$revenue, allocation[1])),   nbins = nrow(frame1) ) / n  pi <- inclusion_prob(frame1$revenue, allocation[1])  dist <- (pi_est - pi) / sqrt(pi * (1 - pi) / n)  plot(   density(dist, na.rm = TRUE),   ylim = c(0, 0.5), xlim = c(-4, 4),   ylab = \"\", xlab = \"\",   main = \"Empirical distribution of inclusion probabilities\" ) lines(seq(-4, 4, 0.1), dnorm(seq(-4, 4, 0.1)), lty = \"dashed\") legend(\"topright\", c(\"empirical\", \"theoretical\"), lty = c(\"solid\", \"dashed\"))"},{"path":"https://marberts.github.io/sps/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Steve Martin. Author, maintainer, copyright holder. Justin Francis. Contributor.","code":""},{"path":"https://marberts.github.io/sps/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Martin S (2025). sps: Sequential Poisson Sampling. doi:10.5281/zenodo.10109857, R package version 0.6.1.9003, https://cran.r-project.org/package=sps.","code":"@Manual{,   title = {{sps}: Sequential Poisson Sampling},   author = {Steve Martin},   year = {2025},   doi = {10.5281/zenodo.10109857},   url = {https://cran.r-project.org/package=sps},   note = {R package version 0.6.1.9003}, }"},{"path":"https://marberts.github.io/sps/index.html","id":"sequential-poisson-sampling-","dir":"","previous_headings":"","what":"Sequential Poisson Sampling","title":"Sequential Poisson Sampling","text":"Sequential Poisson sampling variation Poisson sampling drawing probability-proportional--size samples given number units, commonly used price-index surveys. package gives functions draw stratified sequential Poisson samples according method Ohlsson (1998), well order sample designs Rosén (1997), generate appropriate bootstrap replicate weights according generalized bootstrap method Beaumont Patak (2012).","code":""},{"path":"https://marberts.github.io/sps/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Sequential Poisson Sampling","text":"Get stable release CRAN. development version can installed R-Universe directly GitHub.","code":"install.packages(\"sps\") install.packages(\"sps\", repos = c(\"https://marberts.r-universe.dev\", \"https://cloud.r-project.org\")) pak::pak(\"marberts/sps\")"},{"path":"https://marberts.github.io/sps/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Sequential Poisson Sampling","text":"Given vector sizes units population (e.g., revenue sampling businesses) desired sample size, stratified sequential Poisson sample can drawn sps() function. Allocations often proportional size drawing samples, prop_allocation() function provides variety methods generating proportional--size allocations. design weights sample can used generate bootstrap replicate weights sps_repweights() function. vignette gives detail use functions draw coordinated samples, top sample, estimate variance.","code":"library(sps)  # Generate some data on sizes for 12 businesses in a single  # stratum as a simple example revenue <- c(1:10, 100, 150)  # Draw a sample of 6 businesses (samp <- sps(revenue, 6)) #> [1]  3  6  7  8 11 12  # Design weights and sampling strata are stored with the sample weights(samp) #> [1] 4.583333 2.291667 1.964286 1.718750 1.000000 1.000000 levels(samp) #> [1] \"TS\" \"TS\" \"TS\" \"TS\" \"TA\" \"TA\" # Add some strata stratum <- rep(c(\"a\", \"b\"), c(9, 3))  # Make an allocation (allocation <- prop_allocation(revenue, 6, stratum)) #> a b  #> 3 3  # Draw a stratified sample (samp <- sps(revenue, allocation, stratum)) #> [1]  5  8  9 10 11 12  weights(samp) #> [1] 3.000000 1.875000 1.666667 1.000000 1.000000 1.000000 levels(samp) #> [1] \"TS\" \"TS\" \"TS\" \"TA\" \"TA\" \"TA\" sps_repweights(weights(samp), 5) #>          [,1]     [,2]      [,3]      [,4]     [,5] #> [1,] 5.812219 3.000000 0.1877812 3.0000000 3.000000 #> [2,] 3.515461 3.515461 2.6952305 0.0001875 3.515461 #> [3,] 2.291604 2.916542 2.9165417 1.3541979 1.354198 #> [4,] 1.000000 1.000000 1.0000000 1.0000000 1.000000 #> [5,] 1.000000 1.000000 1.0000000 1.0000000 1.000000 #> [6,] 1.000000 1.000000 1.0000000 1.0000000 1.000000 #> attr(,\"tau\") #> [1] 1.066773"},{"path":"https://marberts.github.io/sps/index.html","id":"prior-work","dir":"","previous_headings":"","what":"Prior work","title":"Sequential Poisson Sampling","text":"number packages CRAN drawing samples proportional size, generally include sequential Poisson method. sampling package contains function drawing sequential Poisson samples, allow stratification, take-units, use permanent random numbers. contrast, prnsamplr package allows use stratification permanent random numbers Pareto order sampling, feature order-sampling methods (like sequential Poisson).","code":""},{"path":"https://marberts.github.io/sps/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Sequential Poisson Sampling","text":"Beaumont, J.-F. Patak, Z. (2012). Generalized Bootstrap Sample Surveys Special Attention Poisson Sampling. International Statistical Review, 80(1): 127-148. Ohlsson, E. (1998). Sequential Poisson Sampling. Journal Official Statistics, 14(2): 149-162. Rosén, B. (1997). sampling probability proportional size. Journal Statistical Planning Inference, 62(2): 159-191.","code":""},{"path":"https://marberts.github.io/sps/reference/expected_coverage.html","id":null,"dir":"Reference","previous_headings":"","what":"Expected coverage — expected_coverage","title":"Expected coverage — expected_coverage","text":"Find expected number strata covered ordinary Poisson sampling without stratification. sequential ordinary Poisson sampling sample size average, gives approximation coverage sequential Poisson sampling. function can also used calculate, e.g., expected number enterprises covered within stratum sampling business establishments.","code":""},{"path":"https://marberts.github.io/sps/reference/expected_coverage.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Expected coverage — expected_coverage","text":"","code":"expected_coverage(x, n, strata, alpha = 0.001, cutoff = Inf)"},{"path":"https://marberts.github.io/sps/reference/expected_coverage.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Expected coverage — expected_coverage","text":"x positive finite numeric vector sizes units population (e.g., revenue drawing sample businesses). n positive integer giving sample size. strata factor, something can coerced one, giving strata associated units population. default place units single stratum. alpha numeric vector values 0 1 stratum, ordered according levels strata. Units inclusion probabilities greater equal 1 - alpha set 1 stratum. single value recycled strata. default slightly larger 0. cutoff positive numeric vector cutoffs stratum, ordered according levels strata. Units x >= cutoff get inclusion probability 1 stratum. single value recycled strata. default apply cutoff.","code":""},{"path":"https://marberts.github.io/sps/reference/expected_coverage.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Expected coverage — expected_coverage","text":"expected number strata covered sample design.","code":""},{"path":[]},{"path":"https://marberts.github.io/sps/reference/expected_coverage.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Expected coverage — expected_coverage","text":"","code":"# Make a population with units of different size x <- c(rep(1:9, each = 3), 100, 100, 100)  # ... and 10 strata s <- rep(letters[1:10], each = 3)  # Should get about 7 to 8 strata in a sample on average expected_coverage(x, 15, s) #> [1] 7.666667"},{"path":"https://marberts.github.io/sps/reference/inclusion_prob.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate inclusion probabilities — inclusion_prob","title":"Calculate inclusion probabilities — inclusion_prob","text":"Calculate stratified (first-order) inclusion probabilities.","code":""},{"path":"https://marberts.github.io/sps/reference/inclusion_prob.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate inclusion probabilities — inclusion_prob","text":"","code":"inclusion_prob(x, n, strata = NULL, alpha = 0.001, cutoff = Inf)  becomes_ta(x, alpha = 0.001, cutoff = Inf)"},{"path":"https://marberts.github.io/sps/reference/inclusion_prob.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate inclusion probabilities — inclusion_prob","text":"x positive finite numeric vector sizes units population (e.g., revenue drawing sample businesses). n positive integer vector giving sample size stratum, ordered according levels strata. single value recycled strata. Non-integers truncated towards 0. strata factor, something can coerced one, giving strata associated units population. default place units single stratum. alpha numeric vector values 0 1 stratum, ordered according levels strata. Units inclusion probabilities greater equal 1 - alpha set 1 stratum. single value recycled strata. default slightly larger 0. cutoff positive numeric vector cutoffs stratum, ordered according levels strata. Units x >= cutoff get inclusion probability 1 stratum. single value recycled strata. default apply cutoff.","code":""},{"path":"https://marberts.github.io/sps/reference/inclusion_prob.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate inclusion probabilities — inclusion_prob","text":"inclusion_prob() returns numeric vector inclusion probabilities unit population. becomes_ta() returns integer vector giving sample size unit enters take-stratum.","code":""},{"path":"https://marberts.github.io/sps/reference/inclusion_prob.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate inclusion probabilities — inclusion_prob","text":"Within stratum, inclusion probability unit given \\(\\pi = nx / \\sum x\\). values can greater 1 practice, constructed iteratively taking units \\(\\pi \\geq 1 - \\alpha\\) (largest smallest) assigning units inclusion probability 1, remaining inclusion probabilities recalculated step. See vignette(\"take-\") details. \\(\\alpha > 0\\), ties among units size broken position. becomes_ta() function reverses operations finds critical sample size unit enters take-stratum. value undefined units always included sample (size exceeds cutoff) never included.","code":""},{"path":"https://marberts.github.io/sps/reference/inclusion_prob.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Calculate inclusion probabilities — inclusion_prob","text":"kit::topn() used available improve performance normal case sample size small relative population.","code":""},{"path":[]},{"path":"https://marberts.github.io/sps/reference/inclusion_prob.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate inclusion probabilities — inclusion_prob","text":"","code":"# Make inclusion probabilities for a population with units # of different size x <- c(1:10, 100) (pi <- inclusion_prob(x, 5)) #>  [1] 0.07272727 0.14545455 0.21818182 0.29090909 0.36363636 0.43636364 #>  [7] 0.50909091 0.58181818 0.65454545 0.72727273 1.00000000  # The last unit is sufficiently large to be included in all # samples with two or more units becomes_ta(x) #>  [1] 11 11 10 10  9  9  8  8  7  7  2  # Use the inclusion probabilities to calculate the variance of the # sample size for Poisson sampling sum(pi * (1 - pi)) #> [1] 1.963636"},{"path":"https://marberts.github.io/sps/reference/prop_allocation.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct a proportional allocation — prop_allocation","title":"Construct a proportional allocation — prop_allocation","text":"Generate proportional--size allocation stratified sampling.","code":""},{"path":"https://marberts.github.io/sps/reference/prop_allocation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct a proportional allocation — prop_allocation","text":"","code":"prop_allocation(   x,   n,   strata,   initial = 0L,   divisor = divisor_method(\"Jefferson/D'Hondt\"),   ties = c(\"largest\", \"first\") )  divisor_method(   name = c(     \"Jefferson/D'Hondt\",     \"Webster/Sainte-Lague\",     \"Imperiali\",     \"Huntington-Hill\",     \"Danish\",     \"Adams\",     \"Dean\"     )   )"},{"path":"https://marberts.github.io/sps/reference/prop_allocation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct a proportional allocation — prop_allocation","text":"x positive finite numeric vector sizes units population (e.g., revenue drawing sample businesses). n positive integer giving sample size. strata factor, something can coerced one, giving strata associated units population. default place units single stratum. initial positive integer vector giving initial (minimal) allocation stratum, ordered according levels strata. single integer recycled stratum using special algorithm ensure feasible allocation; see details. Non-integers truncated towards 0. default allows units allocated stratum. divisor function divisor (highest-averages) apportionment method. default uses Jefferson/D'Hondt method. See details possible functions. ties Either 'largest' break ties favor stratum largest size (default), 'first' break ties favor ordering strata. name Name divisor function. See details.","code":""},{"path":"https://marberts.github.io/sps/reference/prop_allocation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct a proportional allocation — prop_allocation","text":"prop_allocation() returns named integer vector sample sizes stratum strata. divisor_method() returns function giving desired divisor function.","code":""},{"path":"https://marberts.github.io/sps/reference/prop_allocation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Construct a proportional allocation — prop_allocation","text":"prop_allocation() function gives sample size level strata proportional sum x across strata adds n. done using divisor (highest-averages) apportionment method (Balinksi Young, 1982, Appendix ), number different divisor functions: Jefferson/D'Hondt \\() + 1 Webster/Sainte-Laguë \\() + 0.5 Imperiali \\() + 2 Huntington-Hill \\() sqrt(* (+ 1)) Danish \\() + 1 / 3 Adams \\() Dean \\() * (+ 1) / (+ 0.5) Note divisor function \\(d(0) = 0\\) (.e., Huntington-Hill, Adams, Dean) initial allocation least 1 strata. cases, ties broken according sum x ties = 'largest'; otherwise, ties = 'first', ties broken according levels strata. cases number units non-zero size stratum smaller allocation, allocation stratum set number available units, remaining sample size reallocated strata proportional x. similar PROC SURVEYSELECT SAS ALLOC = PROPORTIONAL. Passing single integer initial allocation first checks recycling value stratum result allocation larger sample size. , value reduced recycling exceed sample size. recycled vector can reduced cases exceeds number units stratum, result initial allocation. special recycling ensures initial allocation feasible.","code":""},{"path":"https://marberts.github.io/sps/reference/prop_allocation.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Construct a proportional allocation — prop_allocation","text":"Balinksi, M. L. Young, H. P. (1982). Fair Representation: Meeting Ideal One Man, One Vote. Yale University Press.","code":""},{"path":[]},{"path":"https://marberts.github.io/sps/reference/prop_allocation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct a proportional allocation — prop_allocation","text":"","code":"# Make a population with units of different size x <- c(rep(1:9, each = 3), 100, 100, 100)  # ... and 10 strata s <- rep(letters[1:10], each = 3)  # Generate an allocation prop_allocation(x, 15, s, initial = 1) #> a b c d e f g h i j  #> 1 1 1 1 1 1 2 2 2 3"},{"path":"https://marberts.github.io/sps/reference/sps-package.html","id":null,"dir":"Reference","previous_headings":"","what":"sps: Sequential Poisson Sampling — sps-package","title":"sps: Sequential Poisson Sampling — sps-package","text":"Sequential Poisson sampling variation Poisson sampling drawing probability-proportional--size samples given number units, commonly used price-index surveys. package gives functions draw stratified sequential Poisson samples according method Ohlsson (1998, ISSN:0282-423X), well order sample designs Rosén (1997, doi:10.1016/S0378-3758(96)00186-3 ), generate appropriate bootstrap replicate weights according generalized bootstrap method Beaumont Patak (2012, doi:10.1111/j.1751-5823.2011.00166.x ).","code":""},{"path":[]},{"path":"https://marberts.github.io/sps/reference/sps-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"sps: Sequential Poisson Sampling — sps-package","text":"Maintainer: Steve Martin marberts@protonmail.com (ORCID) [copyright holder] contributors: Justin Francis [contributor]","code":""},{"path":"https://marberts.github.io/sps/reference/sps.html","id":null,"dir":"Reference","previous_headings":"","what":"Stratified sequential Poisson sampling — sps","title":"Stratified sequential Poisson sampling — sps","text":"Draw stratified probability-proportional--size sample using sequential ordinary Poisson methods, generate order sampling schemes.","code":""},{"path":"https://marberts.github.io/sps/reference/sps.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Stratified sequential Poisson sampling — sps","text":"","code":"sps(x, n, strata = NULL, prn = NULL, alpha = 0.001, cutoff = Inf)  ps(x, n, strata = NULL, prn = NULL, alpha = 0.001, cutoff = Inf)  order_sampling(dist)"},{"path":"https://marberts.github.io/sps/reference/sps.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Stratified sequential Poisson sampling — sps","text":"x positive finite numeric vector sizes units population (e.g., revenue drawing sample businesses). n positive integer vector giving sample size stratum, ordered according levels strata. single value recycled strata. Non-integers truncated towards 0. strata factor, something can coerced one, giving strata associated units population. default place units single stratum. prn numeric vector permanent random numbers units population, distributed uniform 0 1. default use permanent random numbers, instead generating random vector function called. alpha numeric vector values 0 1 stratum, ordered according levels strata. Units inclusion probabilities greater equal 1 - alpha set 1 stratum. single value recycled strata. default slightly larger 0. cutoff positive numeric vector cutoffs stratum, ordered according levels strata. Units x >= cutoff get inclusion probability 1 stratum. single value recycled strata. default apply cutoff. dist function giving fixed order distribution shape order sampling scheme. See details.","code":""},{"path":"https://marberts.github.io/sps/reference/sps.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Stratified sequential Poisson sampling — sps","text":"sps() ps() return object class sps_sample. integer vector indices units population form sample, along weights attribute gives design (inverse probability) weights unit sample (keeping mind sequential Poisson sampling approximately probability-proportional--size). weights() can used access design weights attribute sps_sample object, levels() can used determine units take-take-strata. Mathematical binary/unary operators strip attributes, replacement. order_sampling returns function interface sps() ps().","code":""},{"path":"https://marberts.github.io/sps/reference/sps.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Stratified sequential Poisson sampling — sps","text":"sps() function draws sample according sequential Poisson procedure, details given Ohlsson (1998). also called uniform order sampling, type order sampling; see Rosén (1997, 2000) general presentation method. method used PROC SURVEYSELECT SAS METHOD = SEQ_POISSON. stratum, sequential Poisson procedure starts stratifying units population based (target) inclusion probabilities \\(\\pi\\). Units \\(\\pi = 0\\) placed take-none stratum, units \\(0 < \\pi < 1\\) placed take-stratum, units \\(\\pi = 1\\) placed take-stratum. noted Ohlsson (1998), can useful set \\(\\alpha\\) small positive value calculating inclusion probabilities, default behavior. units appropriately stratified, sample take-units drawn assigning unit value \\(\\xi = u / \\pi\\), \\(u\\) random deviate uniform distribution 0 1. units smallest values \\(\\xi\\) included sample, along take-units. (Ties \\(\\xi\\) technically measure-zero event—practice broken position.) results fixed sample size expense sampling procedure approximately probability-proportional--size (.e., inclusion probabilities sample design close exactly equal \\(\\pi\\); see Matei Tillé, 2007, details exact computation). Ordinary Poisson sampling follows procedure , except units \\(\\xi < 1\\) included sample; consequently, contain fixed number units, procedure strictly probability-proportional--size. Despite difference, standard Horvitz-Thompson estimator total (take-stratum) asymptotically unbiased, normally distributed, equally efficient procedures. ps() function draws sample using ordinary Poisson method. useful feature sequential ordinary Poisson sampling ability coordinate samples using permanent random numbers \\(u\\). Keeping \\(u\\) fixed updating sample retains larger number overlapping units, whereas switching \\(u\\) \\(u - z \\bmod 1\\) \\(1 - (u - z \\bmod 1)\\), \\(z\\) 0 1, drawing different samples frame reduces number overlapping units. Despite focus sequential Poisson sampling, order sampling procedures follow approach sequential Poisson sampling. order_sampling() function can used generate order sampling functions passing appropriate function make ranking variable \\(\\xi\\): Sequential Poisson sampling \\(x) x Successive sampling \\(x) log(1 - x) Pareto sampling \\(x) x / (1 - x)","code":""},{"path":"https://marberts.github.io/sps/reference/sps.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Stratified sequential Poisson sampling — sps","text":"kit::topn() used available improve performance normal case sample size small relative population.","code":""},{"path":"https://marberts.github.io/sps/reference/sps.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Stratified sequential Poisson sampling — sps","text":"Matei, ., Tillé, Y. (2007). Computational aspects order \\(\\pi\\)ps sampling schemes. Computational Statistics & Data Analysis, 51: 3703-3717. Ohlsson, E. (1998). Sequential Poisson Sampling. Journal Official Statistics, 14(2): 149-162. Rosén, B. (1997). sampling probability proportional size. Journal Statistical Planning Inference, 62(2): 159-191. Rosén, B. (2000). inclusion probabilities order \\(\\pi\\)ps sampling. Journal Statistical Planning Inference, 90(1): 117-143.","code":""},{"path":[]},{"path":"https://marberts.github.io/sps/reference/sps.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Stratified sequential Poisson sampling — sps","text":"","code":"# Make a population with units of different size x <- c(1:10, 100)  #---- Sequential Poisson sampling ---- # Draw a sequential Poisson sample (samp <- sps(x, 5)) #> [1]  4  5  8 10 11  # Get the design (inverse probability) weights weights(samp) #> [1] 3.43750 2.75000 1.71875 1.37500 1.00000  # All units except 11 are in the take-some (TS) stratum levels(samp) #> [1] \"TS\" \"TS\" \"TS\" \"TS\" \"TA\"  # Ensure that the top 10% of units are in the sample sps(x, 5, cutoff = quantile(x, 0.9)) #> [1]  5  8  9 10 11  #---- Ordinary Poisson sampling ---- # Ordinary Poisson sampling gives a random sample size for the # take-some stratum ps(x, 5) #> [1]  1  6  9 10 11  #---- Stratified Sequential Poisson sampling ---- # Draw a stratified sample with a proportional allocation strata <- rep(letters[1:4], each = 5) (allocation <- prop_allocation(1:20, 12, strata)) #> a b c d  #> 1 2 4 5  (samp <- sps(1:20, allocation, strata)) #>  [1]  4  9 10 11 12 13 14 16 17 18 19 20  # Use the Horvitz-Thompson estimator to estimate the total y <- runif(20) * 1:20 sum(weights(samp) * y[samp]) #> [1] 92.70057  #---- Useful properties of Sequential Poisson sampling ---- # It can be useful to set 'prn' in order to extend the sample # to get a fixed net sample u <- runif(11) (samp <- sps(x, 6, prn = u)) #> [1]  3  6  7  8  9 11  # Removing unit 5 gives the same net sample sps(x[-samp[5]], 6, prn = u[-samp[5]]) #> [1]  3  6  7  8  9 10  # Also useful for topping up a sample all(samp %in% sps(x, 7, prn = u)) #> [1] TRUE  #---- Other order-sampling methods ---- # Generate new order-sampling functions from the parameters of # the inverse generalized Pareto distribution igpd <- function(shape, scale = 1, location = 0) {   if (shape == 0) {     function(x) -scale * log(1 - x) + location   } else {     function(x) scale * (1 - (1 - x)^shape) / shape + location   } }  order_sampling2 <- function(x) order_sampling(igpd(x))  order_sampling2(1)(x, 6, prn = u) # sequential Poisson #> [1]  3  6  7  8  9 11 order_sampling2(0)(x, 6, prn = u) # successive #> [1]  3  6  7  8  9 11 order_sampling2(-1)(x, 6, prn = u) # Pareto #> [1]  3  6  7  8  9 11"},{"path":"https://marberts.github.io/sps/reference/sps_repweights.html","id":null,"dir":"Reference","previous_headings":"","what":"Bootstrap replicate weights for sequential Poisson sampling — sps_repweights","title":"Bootstrap replicate weights for sequential Poisson sampling — sps_repweights","text":"Produce bootstrap replicate weights appropriate Poisson sampling, therefore approximately correct sequential Poisson sampling.","code":""},{"path":"https://marberts.github.io/sps/reference/sps_repweights.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bootstrap replicate weights for sequential Poisson sampling — sps_repweights","text":"","code":"sps_repweights(w, replicates = 1000L, tau = min_tau(1e-04), dist = NULL)  min_tau(tol)"},{"path":"https://marberts.github.io/sps/reference/sps_repweights.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bootstrap replicate weights for sequential Poisson sampling — sps_repweights","text":"w numeric vector design (inverse probability) weights (sequential) Poisson sample. replicates positive integer gives number bootstrap replicates (1,000 default). Non-integers truncated towards 0. tau number greater equal 1 gives rescale factor bootstrap weights. Setting 1 rescale weights. can also function takes vector bootstrap adjustments returns number larger 1. default automatically picks smallest feasible rescale factor (small tolerance). dist function produces random deviates mean 0 standard deviation 1, rnorm(). default uses pseudo-population method section 4.1 Beaumont Patak (2012); see details. tol non-negative number, strictly less 1, gives tolerance determining minimum feasible value tau.","code":""},{"path":"https://marberts.github.io/sps/reference/sps_repweights.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bootstrap replicate weights for sequential Poisson sampling — sps_repweights","text":"sps_repweights() returns matrix bootstrap replicate weights replicates columns (one replicate) length(w) rows (one unit sample), value tau attribute. min_tau() returns function takes vector bootstrap adjustments returns smallest value \\(\\tau\\) rescaled adjustments greater equal tol.","code":""},{"path":"https://marberts.github.io/sps/reference/sps_repweights.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Bootstrap replicate weights for sequential Poisson sampling — sps_repweights","text":"Replicate weights constructed using generalized bootstrap method Beaumont Patak (2012). method takes vector design weights \\(w\\), finds vector adjustments \\(\\) bootstrap replicate, calculates replicate weights \\(w\\). two ways calculate adjustments \\(\\). default pseudo-population method randomly rounds \\(w\\) replicate produce collection integer weights \\(w'\\) used generate random vector \\(b\\) binomial distribution. vector adjustments \\(= 1 + b - w' / w\\). Specifying deviates-generating function dist uses function produce random vector \\(d\\) used make adjustment \\(= 1 + d \\sqrt{1 - 1 / w}\\). adjustments can rescaled value \\(\\tau \\geq 1\\) prevent negative replicate weights. rescaling, adjustment becomes \\((+ \\tau - 1) / \\tau\\). \\(\\tau > 1\\) resulting bootstrap variance estimator multiplied \\(\\tau^2\\).","code":""},{"path":"https://marberts.github.io/sps/reference/sps_repweights.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Bootstrap replicate weights for sequential Poisson sampling — sps_repweights","text":"alternative bootstrap, Ohlsson (1998, equations 2.13) proposes analytic estimator variance total \\(\\hat Y = \\sum wy\\) (take-units) sequential Poisson sampling: $$V(\\hat Y) = \\frac{n}{n - 1} \\sum \\left(1 - \\frac{1}{w}\\right) \\left(wy - \\frac{\\hat Y}{n}\\right)^2.$$ See Rosén (1997, equation 3.11) general version estimator can applied order sampling schemes. Replacing left-correction \\(n / (m - 1)\\), \\(m\\) number units sample, gives similar estimator total ordinary Poisson sampling, \\(\\hat Y = n / m \\sum wy\\).","code":""},{"path":"https://marberts.github.io/sps/reference/sps_repweights.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Bootstrap replicate weights for sequential Poisson sampling — sps_repweights","text":"Beaumont, J.-F. Patak, Z. (2012). Generalized Bootstrap Sample Surveys Special Attention Poisson Sampling. International Statistical Review, 80(1): 127-148. Ohlsson, E. (1998). Sequential Poisson Sampling. Journal Official Statistics, 14(2): 149-162. Rosén, B. (1997). sampling probability proportional size. Journal Statistical Planning Inference, 62(2): 159-191.","code":""},{"path":[]},{"path":"https://marberts.github.io/sps/reference/sps_repweights.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Bootstrap replicate weights for sequential Poisson sampling — sps_repweights","text":"","code":"# Make a population with units of different size x <- c(1:10, 100)  # Draw a sequential Poisson sample (samp <- sps(x, 5)) #> [1]  5  6  9 10 11  # Make some bootstrap replicates dist <- list(   pseudo_population = NULL,   standard_normal = rnorm,   exponential = \\(x) rexp(x) - 1,   uniform = \\(x) runif(x, -sqrt(3), sqrt(3)) )  lapply(dist, sps_repweights, w = weights(samp), replicates = 5, tau = 2) #> $pseudo_population #>          [,1]     [,2]     [,3]      [,4]     [,5] #> [1,] 1.250000 2.625000 1.250000 3.1250000 2.625000 #> [2,] 2.437500 2.437500 3.583333 1.2916667 1.291667 #> [3,] 1.027778 1.291667 1.791667 0.5277778 1.027778 #> [4,] 0.875000 1.562500 0.875000 1.5625000 1.062500 #> [5,] 1.000000 1.000000 1.000000 1.0000000 1.000000 #> attr(,\"tau\") #> [1] 2 #>  #> $standard_normal #>          [,1]     [,2]       [,3]     [,4]     [,5] #> [1,] 3.324661 4.860756 3.96811302 3.215279 4.584936 #> [2,] 2.813617 3.408599 0.04442534 3.206192 1.986830 #> [3,] 1.478419 1.863969 1.45787460 1.998627 1.952668 #> [4,] 1.436819 1.574704 1.53078169 1.361320 1.847787 #> [5,] 1.000000 1.000000 1.00000000 1.000000 1.000000 #> attr(,\"tau\") #> [1] 2 #>  #> $exponential #>          [,1]     [,2]     [,3]     [,4]     [,5] #> [1,] 2.849095 1.839346 2.390392 1.995315 3.469898 #> [2,] 1.450560 2.159272 1.883601 1.606920 4.224309 #> [3,] 1.774187 1.170839 1.690410 1.219775 1.183783 #> [4,] 1.068304 1.080475 1.551248 1.378740 1.086677 #> [5,] 1.000000 1.000000 1.000000 1.000000 1.000000 #> attr(,\"tau\") #> [1] 2 #>  #> $uniform #>           [,1]     [,2]     [,3]     [,4]      [,5] #> [1,] 4.1115291 2.260868 2.912767 3.273160 3.0394871 #> [2,] 2.3443560 3.537325 1.514754 1.982972 1.4510350 #> [3,] 2.2732264 1.804588 1.541610 2.242415 0.9458692 #> [4,] 0.7742958 1.580406 1.272099 1.124584 1.9199455 #> [5,] 1.0000000 1.000000 1.000000 1.000000 1.0000000 #> attr(,\"tau\") #> [1] 2 #>"},{"path":"https://marberts.github.io/sps/news/index.html","id":"sps-development-version","dir":"Changelog","previous_headings":"","what":"sps (development version)","title":"sps (development version)","text":"Added divisor_method() easily generate divisor functions prop_allocation() name. prop_allocation() now faster.","code":""},{"path":"https://marberts.github.io/sps/news/index.html","id":"sps-061","dir":"Changelog","previous_headings":"","what":"sps 0.6.1","title":"sps 0.6.1","text":"CRAN release: 2025-07-10 Added new vignette show inclusion probabilities calculated. inclusion_prob() sps() now use kit::topn() available partial sorting.","code":""},{"path":"https://marberts.github.io/sps/news/index.html","id":"sps-060","dir":"Changelog","previous_headings":"","what":"sps 0.6.0","title":"sps 0.6.0","text":"CRAN release: 2025-02-09 inclusion_prob() now faster single stratum, improving performance sps() expected_coverage(). default, sps_repweights() automatically picks smallest tau keep replicate weights negative. Inspired svrep::make_gen_boot_factors(). Now requires R >= 4.1, case (closing #2).","code":""},{"path":"https://marberts.github.io/sps/news/index.html","id":"sps-054","dir":"Changelog","previous_headings":"","what":"sps 0.5.4","title":"sps 0.5.4","text":"CRAN release: 2024-02-23 Added becomes_ta() determine sample size unit enter take-stratum. Internal changes way classes instantiated. user-visible changes. Updated maintainer email.","code":""},{"path":"https://marberts.github.io/sps/news/index.html","id":"sps-053","dir":"Changelog","previous_headings":"","what":"sps 0.5.3","title":"sps 0.5.3","text":"CRAN release: 2023-10-16 Documentation ; changes functions.","code":""},{"path":"https://marberts.github.io/sps/news/index.html","id":"sps-052","dir":"Changelog","previous_headings":"","what":"sps 0.5.2","title":"sps 0.5.2","text":"CRAN release: 2023-08-22 Added vignette. single sample size now recycled stratum drawing samples calculating inclusion probabilities. Added cutoff argument puts units sizes cutoff take-stratum. sps objects now inherit numeric instead integer. Replacement methods length levels longer mangle sps objects.","code":""},{"path":"https://marberts.github.io/sps/news/index.html","id":"sps-050","dir":"Changelog","previous_headings":"","what":"sps 0.5.0","title":"sps 0.5.0","text":"CRAN release: 2023-04-10 prop_allocation() gets new argument breaking ties. default now breaks ties according references; old behavior can setting ties = \"first\". Argument names prop_allocation(), expected_coverage(), sps_repweights() changed either descriptive, consistent names functions. Fixed bug calculating inclusion probabilities result ties breaking according position (documented) alpha > 0. Simplified codebase.","code":""},{"path":"https://marberts.github.io/sps/news/index.html","id":"sps-041","dir":"Changelog","previous_headings":"","what":"sps 0.4.1","title":"sps 0.4.1","text":"CRAN release: 2023-02-12 Added new argument alpha calculating inclusion probabilities. can used place units inclusion probabilities close 1 take-stratum. implicitly 0 previous versions, current default 1e-4. functions can now accept size vectors zeros. sps() now faster, especially large populations. Added function factory generate order sampling methods.","code":""},{"path":"https://marberts.github.io/sps/news/index.html","id":"sps-030","dir":"Changelog","previous_headings":"","what":"sps 0.3.0","title":"sps 0.3.0","text":"CRAN release: 2022-11-23 version number non-backwards compatible changes address undesirable behavior functions. Largest-remainder rounding result prop_allocation() giving visibly non-proportional allocations, removed. default now Jefferson/D’Hondt method. method argument prop_allocation() replaced divisor argument supply divisor function rounding. initial argument prop_allocation() recycled ensure initial allocation feasible supplying single value. change strictly backwards compatible values ordinarily recycled longer give error. Supplying vector permanent random numbers sps() ps() generated given seed now gives result setting seed prior calling sps() ps(). means setting seed given value can give different sample compared older versions, although permanent random numbers used reproducible samples. argument name specifying strata now strata instead s functions. Partial matching means change won’t break existing code.","code":""},{"path":"https://marberts.github.io/sps/news/index.html","id":"sps-020","dir":"Changelog","previous_headings":"","what":"sps 0.2.0","title":"sps 0.2.0","text":"CRAN release: 2022-10-28 prop_allocation() gains two new arguments: initial sets initial allocation stratum. saves manually keep track initial allocation adjust sample size passed prop_allocation(). method selects apportionment method used round proportional allocation integer values. particular, highest-averages methods can used place largest-remainder method. defaults arguments change behavior function previous versions. convenience functions added: ps() drawing ordinary Poisson samples interface sps(). inclusion_prob() generating inclusion probabilities frame. expected_coverage() calculating expected number strata sampling frame. internals updated improve performance large frames. functions little argument checking. particular, longer possible pass length 0 arguments sps(), prop_allocation(), sps_repweights().","code":""},{"path":"https://marberts.github.io/sps/news/index.html","id":"sps-013","dir":"Changelog","previous_headings":"","what":"sps 0.1.3","title":"sps 0.1.3","text":"CRAN release: 2022-02-09 Added option draw samples permanent random numbers. Added methods Math, Ops, [<-, [[<- strip attributes sps objects treat result sample.","code":""},{"path":"https://marberts.github.io/sps/news/index.html","id":"sps-012","dir":"Changelog","previous_headings":"","what":"sps 0.1.2","title":"sps 0.1.2","text":"CRAN release: 2021-12-11 sps() now returns integer vector (possible), rather double. printing matrix replicate weights now shows row names ().","code":""}]
