
R version 4.2.2 Patched (2022-11-10 r83330) -- "Innocent and Trusting"
Copyright (C) 2022 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> library(sps)
> 
> set.seed(4321)
> 
> # Corner cases
> all.equal(
+   prop_allocation(0, 0, 1),
+   c("1" = 0)
+ )
[1] TRUE
> all.equal(
+   prop_allocation(1:3, 0, 1:3),
+   c("1" = 0, "2" = 0, "3" = 0)
+ )
[1] TRUE
> all.equal(
+   prop_allocation(c(1, 1, 0, 0), 2, gl(2, 2), divisor = identity),
+   c("1" = 2, "2" = 0)
+ )
[1] TRUE
> all.equal(
+   prop_allocation(1:5, 5, gl(1, 5)),
+   c("1" = 5)
+ )
[1] TRUE
> all.equal(
+   prop_allocation(rep(1, 10), 4, factor(rep(letters[1], 10), levels = c("a", "b"))),
+   c(a = 4, b = 0)
+ )
[1] TRUE
> all.equal(
+   prop_allocation(1:4, 2, gl(1, 4), initial = 3),
+   c("1" = 2)
+ )
[1] TRUE
> 
> # Simple allocations
> all.equal(
+   prop_allocation(rep(1, 10), 4, rep(letters[1:2], 5)),
+   c(a = 2, b = 2)
+ )
[1] TRUE
> all.equal(
+   prop_allocation(rep(c(1, 10), 5), 4, rep(letters[1:2], 5)),
+   c(a = 0, b = 4)
+ )
[1] TRUE
> all.equal(
+   prop_allocation(rep(c(1, 10), 5), 4, rep(letters[1:2], 5), initial = 1),
+   c(a = 1, b = 3)
+ )
[1] TRUE
> all.equal(
+   prop_allocation(rep(c(1, 10), 5), 4, rep(letters[1:2], 5), initial = 2),
+   c(a = 2, b = 2)
+ )
[1] TRUE
> all.equal(
+   prop_allocation(c(rep(10, 8), 1, 1), 5, c(rep("a", 8), "b", "b"), initial = 3),
+   c(a = 3, b = 2)
+ )
[1] TRUE
> all.equal(
+   prop_allocation(rep(c(1, 10), 5), 4, rep(letters[1:2], 5), initial = c(3, 1)),
+   c(a = 3, b = 1)
+ )
[1] TRUE
> all.equal(
+   prop_allocation(rep(c(1, 10), 5), 4, factor(rep(letters[1:2], 5), levels = letters[1:3]), initial = c(2, 1, 0)),
+   c(a = 2, b = 2, c = 0)
+ )
[1] TRUE
> all.equal(
+   prop_allocation(c(0, rep(1, 100), 0), 10, rep(1:4, c(11, 20, 30, 41))),
+   c("1" = 1, "2" = 2, "3" = 3, "4" = 4)
+ )
[1] TRUE
> all.equal(
+   prop_allocation(c(0, 0, 100, 1, 1, 1), 3, gl(2, 3)),
+   c("1" = 1, "2" = 2)
+ )
[1] TRUE
> 
> # Multiple iterations
> all.equal(
+   prop_allocation(c(1, 1, 1, 1, 1, 1, 1, 10, 10, 10), 5, rep(letters[1:2], c(7, 3))),
+   c(a = 2, b = 3)
+ )
[1] TRUE
> all.equal(
+   prop_allocation(c(1, 1, 1, 1, 1, 1, 9, 9, 100, 100), 5, rep(letters[1:3], c(6, 2, 2))),
+   c(a = 1, b = 2, c = 2)
+ )
[1] TRUE
> all.equal(
+   prop_allocation(c(1, 1, 1, 1, 1, 1, 9, 9, 100, 100), 5, rep(letters[1:3], c(6, 2, 2)), divisor = identity),
+   c(a = 1, b = 2, c = 2)
+ )
[1] TRUE
> 
> # Allocation for each stratum should add up to total sample size
> all(replicate(50, sum(prop_allocation(rlnorm(50), 10, sample(letters, 50, TRUE))) == 10))
[1] TRUE
> all(replicate(50, sum(prop_allocation(rlnorm(50), 10, sample(letters, 50, TRUE), divisor = function(x) x + 0.5)) == 10))
[1] TRUE
> all(replicate(50, sum(prop_allocation(rlnorm(50), 10, sample(letters, 50, TRUE), divisor = function(x) x + 2)) == 10))
[1] TRUE
> all(replicate(50, sum(prop_allocation(rlnorm(50), 10, sample(letters, 50, TRUE), divisor = function(x) sqrt(x * (x + 1)))) == 10))
[1] TRUE
> all(replicate(50, sum(prop_allocation(rlnorm(50), 10, sample(letters, 50, TRUE), divisor = function(x) x + 1 / 3)) == 10))
[1] TRUE
> all(replicate(50, sum(prop_allocation(rlnorm(50), 10, sample(letters, 50, TRUE), divisor = identity)) == 10))
[1] TRUE
> all(replicate(50, sum(prop_allocation(rlnorm(50), 10, sample(letters, 50, TRUE), divisor = function(x) x * (x + 1) / (x + 0.5))) == 10))
[1] TRUE
> 
> # Alabama paradox
> all.equal(
+   prop_allocation(rep(1, 14), 10, rep(1:3, c(6, 6, 2))),
+   c("1" = 5, "2" = 4, "3" = 1)
+ )
[1] TRUE
> all.equal(
+   prop_allocation(rep(1, 14), 11, rep(1:3, c(6, 6, 2))),
+   c("1" = 5, "2" = 5, "3" = 1)
+ )
[1] TRUE
> 
> # example from https://en.wikipedia.org/wiki/Highest_averages_method
> x <- rep(1, 1e5)
> s <- as.factor(rep(1:6, c(47000, 16000, 15900, 12000, 6000, 3100)))
> 
> all.equal(
+   prop_allocation(x, 10, s),
+   c("1" = 5, "2" = 2, "3" = 2, "4" = 1, "5" = 0, "6" = 0)
+ )
[1] TRUE
> 
> all.equal(
+   prop_allocation(x, 10, s, divisor = function(a) a + 0.5),
+   c("1" = 4, "2" = 2, "3" = 2, "4" = 1, "5" = 1, "6" = 0)
+ )
[1] TRUE
> 
> all.equal(
+   prop_allocation(x, 10, s, divisor = function(a) sqrt(a * (a + 1))),
+   c("1" = 4, "2" = 2, "3" = 1, "4" = 1, "5" = 1, "6" = 1)
+ )
[1] TRUE
> 
> all.equal(
+   prop_allocation(x, 10, s, divisor = function(a) a),
+   c("1" = 3, "2" = 2, "3" = 2, "4" = 1, "5" = 1, "6" = 1)
+ )
[1] TRUE
> 
> # Test coverage
> all.equal(expected_coverage(1:6, 6, gl(1, 6)), 1)
[1] TRUE
> all.equal(expected_coverage(1:6, 0, gl(1, 6)), 0)
[1] TRUE
> all.equal(expected_coverage(1:6, 3, 1:6), 3)
[1] TRUE
> 
> all.equal(
+   expected_coverage(1:10, 4, gl(2, 5)),
+   expected_coverage(1:10, 4, gl(2, 5, labels = 1:3))
+ )
[1] TRUE
>
> # Bernoulli sampling
> all.equal(
+     expected_coverage(rep(1, 10), 4, c(rep(1, 4), rep(2, 6))),
+     2 - (1 - 0.4)^4 - (1 - 0.4)^6
+ )
[1] TRUE
>
> # Simulation
> x <- c(0, 20, 16, 32, 14, 35, 9, 6, 2, 33, 29, 40, 27, 38, 47, 26, 46, 
+        12, 11, 39, 24, 100, 0, 1, 6, 6, 9, 20, 15, 25, 14, 0, 100)
> s <- c(4, 4, 2, 5, 5, 5, 5, 2, 3, 2, 5, 2, 2, 5, 5, 2, 3, 4, 5, 5, 3, 4, 
+        2, 2, 2, 3, 5, 2, 1, 1, 2, 3, 3)
> 
> expected_coverage(x, 10, s)
[1] 4.412826
> 
> # mean(replicate(1e3, length(unique(s[ps(x, 10)]))))
> 
> proc.time()
   user  system elapsed 
  0.773   0.215   0.921 
